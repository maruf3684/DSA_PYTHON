üîπ Isolation Levels (from weakest ‚Üí strongest)
	1.	Read Uncommitted
	‚Ä¢	Allows dirty reads (can see uncommitted changes from other transactions).
	‚Ä¢	Fastest but least safe.
	‚Ä¢	Problems: Dirty Read, Non-Repeatable Read, Phantom Read.

	2.	Read Committed
	‚Ä¢	Prevents dirty reads (only reads committed data).
	‚Ä¢	Default in many databases (like Oracle, PostgreSQL).
	‚Ä¢	Problems: Non-Repeatable Read, Phantom Read.

	3.	Repeatable Read
	‚Ä¢	Ensures same row returns consistent values within a transaction.
	‚Ä¢	Prevents dirty & non-repeatable reads.
	‚Ä¢	Problems: Phantom Read (new rows can appear).
	‚Ä¢	Default in MySQL (InnoDB).

	4.	Serializable
	‚Ä¢	Strictest level: transactions execute as if sequentially.
	‚Ä¢	Prevents dirty, non-repeatable, and phantom reads.
	‚Ä¢	Safest but slowest (uses locks or MVCC with validation).



	üîπ Trade-off
	‚Ä¢	Higher isolation = more consistency, less concurrency.
	‚Ä¢	Lower isolation = better performance, more anomalies possible.



.........................................................No SQL...................................................
2Ô∏è‚É£ Isolation
	‚Ä¢	RDBMS: Supports multiple levels of isolation (Read Uncommitted ‚Üí Serializable) to control concurrency anomalies.
	‚Ä¢	NoSQL:
	‚Ä¢	Isolation is weaker or configurable.
	‚Ä¢	Many NoSQL DBs are eventually consistent, meaning concurrent reads may see intermediate states.
	‚Ä¢	Example: Cassandra uses read-your-own-write option, but in general two clients can read different versions of the same row temporarily.

‚∏ª

3Ô∏è‚É£ Consistency
	‚Ä¢	RDBMS: Always enforced by DB (schema, constraints, foreign keys).
	‚Ä¢	NoSQL: Optional. May be violated unless explicitly configured.

‚∏ª

4Ô∏è‚É£ Durability
	‚Ä¢	RDBMS: Guaranteed once committed.
	‚Ä¢	NoSQL: Depends on config (memory-first vs disk, replication). Can lose recent writes on crash.

‚∏ª
