ğŸ”¹ Durability (ACID Property)
	â€¢	Once a transaction is committed, changes are permanent.
	â€¢	Survives power loss, crash, or system failure.
	â€¢	Ensured using transaction logs / write-ahead logging (WAL) / journaling.
	â€¢	RDBMS: strict guarantee â†’ commit = data is safe.
	â€¢	NoSQL: durability often configurable (may trade durability for speed).
	â€¢	Example:
	â€¢	Bank transfer committed â†’ even if server crashes, money movement is not lost.


...................................................NO SQL..............................................

ğŸ”¹ Why NoSQL Can Fail Durability
	â€¢	Memory-first storage
	â€¢	Some NoSQL DBs (e.g., Redis, Memcached) keep data in RAM for speed.
	â€¢	If crash happens before data is flushed to disk â†’ data is lost.
	â€¢	Asynchronous writes
	â€¢	Many NoSQL systems confirm â€œwrite successâ€ before fsync (disk flush).
	â€¢	Example: MongoDB can acknowledge writes without journaling.
	â€¢	Eventual consistency model
	â€¢	In distributed NoSQL (Cassandra, DynamoDB, etc.), a write might be accepted on one replica but not yet replicated to others.
	â€¢	Crash/node failure before replication â†’ data loss.
	â€¢	Configurable durability levels
	â€¢	MongoDB writeConcern = {w:1} (acknowledge from 1 node) can lose data if that node fails before syncing to others.
	â€¢	Stronger durability needs {w:majority, j:true} but with performance cost.
	â€¢	Replication lag
	â€¢	In systems with async replication, primary crash can cause committed writes to vanish if they didnâ€™t reach replicas yet.

â¸»

ğŸ”¹ Example Scenarios
	1.	Redis (default mode)
	â€¢	Writes stored in memory, disk flush every few seconds.
	â€¢	Crash â†’ last few seconds of writes lost.

	2.	MongoDB
	â€¢	Insert with writeConcern:1 â†’ acknowledged after memory write.
	â€¢	If server crashes before journal/disk write â†’ lost.

	3.	Cassandra
	â€¢	Write goes to one replica, acknowledged.
	â€¢	Before replication to other nodes, that replica dies â†’ lost.





